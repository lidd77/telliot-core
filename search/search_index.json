{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Telliot's documentation \u00b6 Overview \u00b6 Telliot is a Python framework for interacting with the decentralized TellorX network. With Telliot, you (or your smart contract) can: Ask the TellorX Decentralized Oracle to answer a question (we call that tipping ) Submit answers to questions that other people (or smart contracts) ask. (we call that reporting . Reporters earn tips, but must stake TRB as collateral against incorrect answers) Look up historical answers. Help maintain the security of the TellorX network by disputing inaccurate answers and voting on other disputes. Of course, TellorX supports DeFi with questions such as \"What is the current price of Bitcoin in US Dollars?\" But that is just the beginning. TellorX also supports arbitrary questions and answers. Any question is OK, provided that the Tellor community can answer it with a reasonable degree of confidence (remember, Reporters may lose TRB if the network votes the answer incorrect!) Telliot Software \u00b6 The telliot software currently consists of two main python packages: Telliot Core This package provides core functionality and a plugin framework for use by other Telliot subpackages and custom data feeds. Telliot Feed Examples This package provides several working examples of data feeds that can be either customized or used directly. Scope \u00b6 Telliot aims to make it easier to ask questions in a format that the Oracle can understand, and specify the format (i.e. data structure) of the answers you would like to receive - so that the community can answer them more reliably. The TellorX network is open to everyone, and Telliot is just one way to access it. You can use all of Telliot, parts of it, or not use it at all. You can also make contributions to improve it. !!! warning Use Telliot at your own risk. It may have bugs! Bugs may cost you real money! If you find any, please submit an issue , or better yet create a pull request with a suggested fix.","title":"Home"},{"location":"#welcome-to-telliots-documentation","text":"","title":"Welcome to Telliot's documentation"},{"location":"#overview","text":"Telliot is a Python framework for interacting with the decentralized TellorX network. With Telliot, you (or your smart contract) can: Ask the TellorX Decentralized Oracle to answer a question (we call that tipping ) Submit answers to questions that other people (or smart contracts) ask. (we call that reporting . Reporters earn tips, but must stake TRB as collateral against incorrect answers) Look up historical answers. Help maintain the security of the TellorX network by disputing inaccurate answers and voting on other disputes. Of course, TellorX supports DeFi with questions such as \"What is the current price of Bitcoin in US Dollars?\" But that is just the beginning. TellorX also supports arbitrary questions and answers. Any question is OK, provided that the Tellor community can answer it with a reasonable degree of confidence (remember, Reporters may lose TRB if the network votes the answer incorrect!)","title":"Overview"},{"location":"#telliot-software","text":"The telliot software currently consists of two main python packages: Telliot Core This package provides core functionality and a plugin framework for use by other Telliot subpackages and custom data feeds. Telliot Feed Examples This package provides several working examples of data feeds that can be either customized or used directly.","title":"Telliot Software"},{"location":"#scope","text":"Telliot aims to make it easier to ask questions in a format that the Oracle can understand, and specify the format (i.e. data structure) of the answers you would like to receive - so that the community can answer them more reliably. The TellorX network is open to everyone, and Telliot is just one way to access it. You can use all of Telliot, parts of it, or not use it at all. You can also make contributions to improve it. !!! warning Use Telliot at your own risk. It may have bugs! Bugs may cost you real money! If you find any, please submit an issue , or better yet create a pull request with a suggested fix.","title":"Scope"},{"location":"contributing/","text":"Contributing \u00b6 Development Environment Setup \u00b6 These instructions assume that a working Python interpreter (version >=3.9) is already installed on the system. Clone the repository to a local working directory: git clone https://github.com/tellor-io/telliot-core.git Create and activate a virtual environment . In this example, the virtual environment is located in a subfolder called tenv : Linux Windows python3 -m venv tenv source tenv/bin/activate py -m venv tenv tenv\\Scripts\\activate If working on Ubuntu, may need to install one of the following packages ( see this issue ). sudo apt install libpython3.9-dev Install the project using using an editable installation . pip install -e . pip install -r requirements-dev.txt Test Environment \u00b6 Make sure you've configured Telliot before continuing. Verify the development environment by running pytest and ensure that all tests pass. pytest Making Contributions \u00b6 Once your dev environment is set up, make desired changes, create new tests for those changes, and conform to the style & typing format of the project. To do so, in the project home directory: Run all unit tests: pytest Check code typing: tox -e typing Check style (you may need run this step several times): tox -e style Once all those pass, you're ready to make a pull request to the project's main branch. Link any related issues, tag desired reviewers, and watch the #telliot-core channel in the community discord for updates. New Release Process/Checklist \u00b6 For manually creating a new package version release: Ensure all tests are passing on main. Remove \"dev\" from version in the main package's init .py . Example: version = \"0.0.5dev\" --> version = \"0.0.5\". On Github, go to Releases-->Draft a new release-->Choose a tag Write in a new tag that corresponds with the version in init .py. Example: v.0.0.5 If the tag is v.0.0.5, the release title should be Release 0.0.5. Click Auto-generate release notes. Check the box for This is a pre-release. Click Publish release. Navigate to the Actions tab from the main page of the package on github and make sure the release workflow completes successfully. Check to make sure the new version was released to test PyPI here . Test downloading and using the new version of the package from test PyPI ( example ). Navigate back to the pre-release you just made and click edit (the pencil icon). Uncheck the This is a pre-release box. Publish the release. Make sure the release github action goes through. Download and test the new release on PyPI official here . Change the package version in init .py to be the next development version. For example, if you just released version 0.0.5, change version to be \"0.0.6dev0\".","title":"Developer's Guide"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#development-environment-setup","text":"These instructions assume that a working Python interpreter (version >=3.9) is already installed on the system. Clone the repository to a local working directory: git clone https://github.com/tellor-io/telliot-core.git Create and activate a virtual environment . In this example, the virtual environment is located in a subfolder called tenv : Linux Windows python3 -m venv tenv source tenv/bin/activate py -m venv tenv tenv\\Scripts\\activate If working on Ubuntu, may need to install one of the following packages ( see this issue ). sudo apt install libpython3.9-dev Install the project using using an editable installation . pip install -e . pip install -r requirements-dev.txt","title":"Development Environment Setup"},{"location":"contributing/#test-environment","text":"Make sure you've configured Telliot before continuing. Verify the development environment by running pytest and ensure that all tests pass. pytest","title":"Test Environment"},{"location":"contributing/#making-contributions","text":"Once your dev environment is set up, make desired changes, create new tests for those changes, and conform to the style & typing format of the project. To do so, in the project home directory: Run all unit tests: pytest Check code typing: tox -e typing Check style (you may need run this step several times): tox -e style Once all those pass, you're ready to make a pull request to the project's main branch. Link any related issues, tag desired reviewers, and watch the #telliot-core channel in the community discord for updates.","title":"Making Contributions"},{"location":"contributing/#new-release-processchecklist","text":"For manually creating a new package version release: Ensure all tests are passing on main. Remove \"dev\" from version in the main package's init .py . Example: version = \"0.0.5dev\" --> version = \"0.0.5\". On Github, go to Releases-->Draft a new release-->Choose a tag Write in a new tag that corresponds with the version in init .py. Example: v.0.0.5 If the tag is v.0.0.5, the release title should be Release 0.0.5. Click Auto-generate release notes. Check the box for This is a pre-release. Click Publish release. Navigate to the Actions tab from the main page of the package on github and make sure the release workflow completes successfully. Check to make sure the new version was released to test PyPI here . Test downloading and using the new version of the package from test PyPI ( example ). Navigate back to the pre-release you just made and click edit (the pencil icon). Uncheck the This is a pre-release box. Publish the release. Make sure the release github action goes through. Download and test the new release on PyPI official here . Change the package version in init .py to be the next development version. For example, if you just released version 0.0.5, change version to be \"0.0.6dev0\".","title":"New Release Process/Checklist"},{"location":"documentation/","text":"Project Documentation \u00b6 Telliot is documented using Material for MkDocs . The latest telliot-core documentation can be found here To compile and view local changes to documentation, use the following command, then open a browser to the link displayed: mkdocs serve Documentation Reference \u00b6 Portions of the documentation are auto-generated from Python docstrings using: github.com/mkdocstrings/mkdocstrings Documentation for this package is available here: mkdocstrings.github.io/usage","title":"Documentation"},{"location":"documentation/#project-documentation","text":"Telliot is documented using Material for MkDocs . The latest telliot-core documentation can be found here To compile and view local changes to documentation, use the following command, then open a browser to the link displayed: mkdocs serve","title":"Project Documentation"},{"location":"documentation/#documentation-reference","text":"Portions of the documentation are auto-generated from Python docstrings using: github.com/mkdocstrings/mkdocstrings Documentation for this package is available here: mkdocstrings.github.io/usage","title":"Documentation Reference"},{"location":"getting-started/","text":"Getting Started \u00b6 Telliot Configuration \u00b6 After installation of the telliot-core or any telliot data feeds, Telliot must be personalized to use your own private keys and endpoints. First, create the default configuration files: telliot config init The default configuration files are created in a folder called telliot in the user home folder. To show the current configuration: telliot config show Main Configuration File \u00b6 The main configuration file allows you to choose the default network Telliot will interact with. By default, Telliot is configured to run on Rinkeby testnet, as shown in the example below. Edit the ~/telliot/main.yaml config file for the desired configuration. To run on Ethereum mainnet, use chain_id: 1 and network: mainnet . To submit values to the Tellor oracle, a private_key must also be configured. Example main configuration file: type : MainConfig loglevel : INFO chain_id : 4 Configure Accounts \u00b6 Telliot needs to know which accounts are available for contract writes, such as submitting values to the oracle. Use the command line to add necessary accounts/private keys. For example, to add an account called my-matic-acct for reporting on polygon mainnet (EVM chain_id=137): >> chained add my-matic-acct 0x57fe7105302229455bcfd58a8b531b532d7a2bb3b50e1026afa455cd332bf706 137 Enter encryption password for my-matic-acct: Confirm password: Added new account my-matic-acct (address= 0xcd19cf65af3a3aea1f44a7cb0257fc7455f245f0) for use on chains (137,) Note that reporting accounts can be used for ETH mainnet (chain_id=1), Rinkeby testnet (chain_id=4), or Polygon testnet (chain_id=80001). Also note that a single account/private key can be associated with multiple chains. Detailed instructions for managing EVM accounts can be found in the chained_accounts package documentation . Configure endpoints \u00b6 Edit ~/telliot/endpoints.yaml to configure Telliot to use your own endpoints. If you don't have an endpoint, a free one is available at Infura.io . Simply replace INFURA_API_KEY with the one provided by Infura. Endpoints should be configured for both Ethereum mainnet and Rinkeby testnet. Warning All telliot software and reporter feeds should be validated on Rinkeby prior to deploying on mainnet. Note that endpoints must use the websocket protocol because HTTPS endpoints do not support event listeners. Example endpoints.yaml file: type : EndpointList endpoints : - type : RPCEndpoint chain_id : 1 network : mainnet provider : Infura url : wss://mainnet.infura.io/ws/v3/{INFURA_API_KEY} explorer : https://etherscan.io - type : RPCEndpoint chain_id : 4 network : rinkeby provider : Infura url : wss://rinkeby.infura.io/ws/v3/{INFURA_API_KEY} explorer : https://rinkeby.etherscan.io Add API Keys \u00b6 Some data sources used for reporting require you to set up an account and use an API key for authenticating requests. Edit ~/telliot/api_keys.yaml to add any API keys needed for reporting data like AMPL/USD/VWAP and BCT/USD. Example api_keys.yaml file: type : ApiKeyList api_keys : - type : ApiKey name : anyblock key : 'YOUR API KEY GOES HERE' url : https://api.anyblock.tools/ - type : ApiKey name : bravenewcoin key : 'YOUR API KEY GOES HERE' url : https://bravenewcoin.p.rapidapi.com/ ...","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#telliot-configuration","text":"After installation of the telliot-core or any telliot data feeds, Telliot must be personalized to use your own private keys and endpoints. First, create the default configuration files: telliot config init The default configuration files are created in a folder called telliot in the user home folder. To show the current configuration: telliot config show","title":"Telliot Configuration"},{"location":"getting-started/#main-configuration-file","text":"The main configuration file allows you to choose the default network Telliot will interact with. By default, Telliot is configured to run on Rinkeby testnet, as shown in the example below. Edit the ~/telliot/main.yaml config file for the desired configuration. To run on Ethereum mainnet, use chain_id: 1 and network: mainnet . To submit values to the Tellor oracle, a private_key must also be configured. Example main configuration file: type : MainConfig loglevel : INFO chain_id : 4","title":"Main Configuration File"},{"location":"getting-started/#configure-accounts","text":"Telliot needs to know which accounts are available for contract writes, such as submitting values to the oracle. Use the command line to add necessary accounts/private keys. For example, to add an account called my-matic-acct for reporting on polygon mainnet (EVM chain_id=137): >> chained add my-matic-acct 0x57fe7105302229455bcfd58a8b531b532d7a2bb3b50e1026afa455cd332bf706 137 Enter encryption password for my-matic-acct: Confirm password: Added new account my-matic-acct (address= 0xcd19cf65af3a3aea1f44a7cb0257fc7455f245f0) for use on chains (137,) Note that reporting accounts can be used for ETH mainnet (chain_id=1), Rinkeby testnet (chain_id=4), or Polygon testnet (chain_id=80001). Also note that a single account/private key can be associated with multiple chains. Detailed instructions for managing EVM accounts can be found in the chained_accounts package documentation .","title":"Configure Accounts"},{"location":"getting-started/#configure-endpoints","text":"Edit ~/telliot/endpoints.yaml to configure Telliot to use your own endpoints. If you don't have an endpoint, a free one is available at Infura.io . Simply replace INFURA_API_KEY with the one provided by Infura. Endpoints should be configured for both Ethereum mainnet and Rinkeby testnet. Warning All telliot software and reporter feeds should be validated on Rinkeby prior to deploying on mainnet. Note that endpoints must use the websocket protocol because HTTPS endpoints do not support event listeners. Example endpoints.yaml file: type : EndpointList endpoints : - type : RPCEndpoint chain_id : 1 network : mainnet provider : Infura url : wss://mainnet.infura.io/ws/v3/{INFURA_API_KEY} explorer : https://etherscan.io - type : RPCEndpoint chain_id : 4 network : rinkeby provider : Infura url : wss://rinkeby.infura.io/ws/v3/{INFURA_API_KEY} explorer : https://rinkeby.etherscan.io","title":"Configure endpoints"},{"location":"getting-started/#add-api-keys","text":"Some data sources used for reporting require you to set up an account and use an API key for authenticating requests. Edit ~/telliot/api_keys.yaml to add any API keys needed for reporting data like AMPL/USD/VWAP and BCT/USD. Example api_keys.yaml file: type : ApiKeyList api_keys : - type : ApiKey name : anyblock key : 'YOUR API KEY GOES HERE' url : https://api.anyblock.tools/ - type : ApiKey name : bravenewcoin key : 'YOUR API KEY GOES HERE' url : https://bravenewcoin.p.rapidapi.com/ ...","title":"Add API Keys"},{"location":"new-query/","text":"Creating New or Custom Oracle Queries \u00b6 If the Tellor oracle doesn't have the on-chain data your smart contract needs, this section should help you define a new query so that Tellor's decentralized network of reporters can get busy putting your data securely on-chain. The Art of Query Design \u00b6 Creating new Tellor query is pretty simple - there are only a few steps. Along the way, though, there are some important considerations and decisions to make so that Tellor's oracle data serves your project well. Here's how to get started. Step 1. Give the query a name Call it anything, really (within reason of course). WeatherReport , GameScore , ElectionResult , PropertyOwner , or anything else you can imagine. We call this the Query Type . If you stick with CamelCase names, it would really help us out, so thanks in advance! Step 2. Choose query parameters (if you want to) A Query Type can also have parameters that serve to customize the response. For example, PropertyOwner might have a parameter called address . GameScore might have a few parameters such as game_date , home_team , or away_team . You get the idea. It helps if you also define what values are allowed for each parameter . One last thing - we know it seems weird, but we'd love it if you named your parameters using SnakeCase . Step 3. Choose the data type Tellor's reporters need to know how you'd like your data served (medium rare, a side of fries?). When you think about it, reporters need to know the data type used to respond, such as float , int , string , bool`, raw bytes, etc. But don't stop there. Interesting queries can have complex responses with structured data types that can hold data such as weather reports, addresses, GPS locations, game statistics. That's the great thing about Tellor, you can have it your way ! Step 4. You make the rules Since it's your data used for your smart contract, you get to make the rules! With great power (to create arbitrary queries with arbitrary responses) comes great responsibility. Rules about your data are mainly to encourage Tellor's reporters to provide the data with a reasonable degree of confidence. Remember, reporters may lose their staked TRB if the network votes the answer incorrect! This is the part of Query Design that is more of an art . Be sure to carefully describe the expected response, including the conditions that you would expect for the value to be disputed and removed from the chain. Depending on your design, the rules can have a great impact on the security of your network. Step 5. Define data sources (if you want to) Another optional step here. Reporters will need to figure out how to get the requested data. If the rules are clear, you can leave it up to them - that's totally cool. Otherwise, you can point reporters in the right direction. Ideally there are multiple off-chain data sources to increase the robustness and decentralization of the feed. Sometimes there are specific API endpoints that have exactly the data that you're looking for. If endpoints are paid, you might have to tip reporters a bit more as an incentive for the feed. That's it! You've learned the art of Tellor Query design, including some important things to consider in the process. Please reach out to the integrations team on discord for more help in getting started. If you're a dev, you can continue reading for a detailed technical guide for adding new queries to the tellor network. Detailed Guide \u00b6 This section begins a detailed technical description of how to add a new query to the Tellor network. The process of adding a new query to the Tellor network involves three steps: Define the new query Register the new query Create a data source to provide data for the new query Technically speaking, the 3rd step above is not required, but it enables Tellor's existing decentralized reporter network to automatically respond to the query. Without this step, customers will be required to stand-up their own reporter network. Step 1: Query Definition \u00b6 To define a new query, the first step is to specify its Query Type . If possible, it's easiest to use one of the Query Types already defined for the Tellor network ( e.g. SpotPrice ). If none of the existing query types work, you will need to define a new query type . When using an existing Query Type, you'll need to specify the parameter values that correspond to the data you would like put on-chain. For example, when using the SpotPrice query, you'll need to specify the values for two parameters: asset and currency . It is important to note the difference between defining a Query Type and a defining a query . Defining a new Query Type creates an entire new class of queries, whereas defining a new query refers to an instance of a QueryType with the value of each parameter specified. To formally add the query definition to Tellor network, you'll need to propose changes to the Tellor Data Specification Repository . Step 2: Query Registration \u00b6 Registering the new query makes users aware of the query and lets reporters know how to respond. It requires proposing changes to the telliot-core repository , and must include two things. First, it must include a unit test for the new query. Using the pytest framework, create a unit test that creates an instance of the query and verify that the values query descriptor, query data, and query ID are sensible. Second, it must be registered with the Query Catalog . The example below demonstrates how to test a new query and register it in the catalog. Step 3: Query Data Sources \u00b6 A query DataSource provides a method to fetch new data points in response to a query. It provides an API that enables Tellor's existing decentralized reporter network to automatically respond to the query. Ideally, a DataSource should provide additional decentralization and robustness by fetching data from multiple sources and aggregating the result. A new DataSource is created by proposing changes to the telliot-feed-examples repository . Defining New Query Types \u00b6 If none of the existing Tellor Query Types works for your application, you can define a new Query Type . A new Query Type definition specifies: The name of the query type The data type or structure of the value expected query response (i.e. its ValueType ) Optionally, the name and data type of each query parameter Encoding method - the method used to encode the Query Type and parameter values into the query_data field used for Tellor contract interactions. It is important to note the difference between defining a Query Type and a defining a query . Defining a new Query Type creates an entire new class of queries, whereas defining a new query refers to an instance of a QueryType with the value of each parameter specified. To define a new Query Type, propose changes to the telliot-core repository defining a new subclass of OracleQuery that implements all required methods and properties. New users may choose between subclassing JsonQuery and the AbiQuery . These queries are identical in every way except for the coder/decoder that converts between the query name/parameters and the query data field used in contract interfaces. The latter format is recommended if on-chain read/write access to parameter values is required. You'll also need to create a test file for your new Query Type . To get the query_data and query_id in hex format, open up a Python shell and enter the following. We'll be using the [ Snapshot ] query as an example. from telliot_core.queries.snapshot import Snapshot q = Snapshot ( proposal_id = \"QmbZ6cYVvfoKvkDX14jRcN86z6bfV135npUfhxmENjHnQ1\" ) q . query_data q . query_id . hex () Propose changes \u00b6 To propose changes to a Tellor repository, perform the following steps: Fork the tellor repository to your github account. Follow our developer's guide and make the proposed changes in your forked repository. Submit a pull-request to incorporate the changes from your fork into the main tellor repository. Alternately, standalone changes can be proposed in a separate repository, but it is the user's responsibility to ensure compatibility with the telliot-core framework. Example: Adding a new SpotPrice \u00b6 In this example, a new SpotPrice query is defined for the price of BTC in USD. To add a new spot price, use the existing SpotPrice Query Type and simply define a new asset / currency pair. Example: Create and test the SpotPrice query for BTC/USD. from telliot_core.api import SpotPrice def test_new_query (): q = SpotPrice ( asset = \"BTC\" , currency = \"USD\" ) assert q . descriptor == '{\"type\":\"SpotPrice\",\"asset\":\"btc\",\"currency\":\"usd\"}' assert q . query_data == b '{\"type\":\"SpotPrice\",\"asset\":\"btc\",\"currency\":\"usd\"}' assert q . query_id . hex () == \"d66b36afdec822c56014e56f468dee7c7b082ed873aba0f7663ec7c6f25d2c0a\" Example: Add the query to the Query Catalog Add the following statements to telliot_core.data.query_catalog.py . query_catalog . add_entry ( tag = \"btc-usd-spot\" , title = \"BTC/USD spot price\" , q = SpotPrice ( asset = \"BTC\" , currency = \"USD\" ) )","title":"Creating New Queries"},{"location":"new-query/#creating-new-or-custom-oracle-queries","text":"If the Tellor oracle doesn't have the on-chain data your smart contract needs, this section should help you define a new query so that Tellor's decentralized network of reporters can get busy putting your data securely on-chain.","title":"Creating New or Custom Oracle Queries"},{"location":"new-query/#the-art-of-query-design","text":"Creating new Tellor query is pretty simple - there are only a few steps. Along the way, though, there are some important considerations and decisions to make so that Tellor's oracle data serves your project well. Here's how to get started. Step 1. Give the query a name Call it anything, really (within reason of course). WeatherReport , GameScore , ElectionResult , PropertyOwner , or anything else you can imagine. We call this the Query Type . If you stick with CamelCase names, it would really help us out, so thanks in advance! Step 2. Choose query parameters (if you want to) A Query Type can also have parameters that serve to customize the response. For example, PropertyOwner might have a parameter called address . GameScore might have a few parameters such as game_date , home_team , or away_team . You get the idea. It helps if you also define what values are allowed for each parameter . One last thing - we know it seems weird, but we'd love it if you named your parameters using SnakeCase . Step 3. Choose the data type Tellor's reporters need to know how you'd like your data served (medium rare, a side of fries?). When you think about it, reporters need to know the data type used to respond, such as float , int , string , bool`, raw bytes, etc. But don't stop there. Interesting queries can have complex responses with structured data types that can hold data such as weather reports, addresses, GPS locations, game statistics. That's the great thing about Tellor, you can have it your way ! Step 4. You make the rules Since it's your data used for your smart contract, you get to make the rules! With great power (to create arbitrary queries with arbitrary responses) comes great responsibility. Rules about your data are mainly to encourage Tellor's reporters to provide the data with a reasonable degree of confidence. Remember, reporters may lose their staked TRB if the network votes the answer incorrect! This is the part of Query Design that is more of an art . Be sure to carefully describe the expected response, including the conditions that you would expect for the value to be disputed and removed from the chain. Depending on your design, the rules can have a great impact on the security of your network. Step 5. Define data sources (if you want to) Another optional step here. Reporters will need to figure out how to get the requested data. If the rules are clear, you can leave it up to them - that's totally cool. Otherwise, you can point reporters in the right direction. Ideally there are multiple off-chain data sources to increase the robustness and decentralization of the feed. Sometimes there are specific API endpoints that have exactly the data that you're looking for. If endpoints are paid, you might have to tip reporters a bit more as an incentive for the feed. That's it! You've learned the art of Tellor Query design, including some important things to consider in the process. Please reach out to the integrations team on discord for more help in getting started. If you're a dev, you can continue reading for a detailed technical guide for adding new queries to the tellor network.","title":"The Art of Query Design"},{"location":"new-query/#detailed-guide","text":"This section begins a detailed technical description of how to add a new query to the Tellor network. The process of adding a new query to the Tellor network involves three steps: Define the new query Register the new query Create a data source to provide data for the new query Technically speaking, the 3rd step above is not required, but it enables Tellor's existing decentralized reporter network to automatically respond to the query. Without this step, customers will be required to stand-up their own reporter network.","title":"Detailed Guide"},{"location":"new-query/#step-1-query-definition","text":"To define a new query, the first step is to specify its Query Type . If possible, it's easiest to use one of the Query Types already defined for the Tellor network ( e.g. SpotPrice ). If none of the existing query types work, you will need to define a new query type . When using an existing Query Type, you'll need to specify the parameter values that correspond to the data you would like put on-chain. For example, when using the SpotPrice query, you'll need to specify the values for two parameters: asset and currency . It is important to note the difference between defining a Query Type and a defining a query . Defining a new Query Type creates an entire new class of queries, whereas defining a new query refers to an instance of a QueryType with the value of each parameter specified. To formally add the query definition to Tellor network, you'll need to propose changes to the Tellor Data Specification Repository .","title":"Step 1: Query Definition"},{"location":"new-query/#step-2-query-registration","text":"Registering the new query makes users aware of the query and lets reporters know how to respond. It requires proposing changes to the telliot-core repository , and must include two things. First, it must include a unit test for the new query. Using the pytest framework, create a unit test that creates an instance of the query and verify that the values query descriptor, query data, and query ID are sensible. Second, it must be registered with the Query Catalog . The example below demonstrates how to test a new query and register it in the catalog.","title":"Step 2: Query Registration"},{"location":"new-query/#step-3-query-data-sources","text":"A query DataSource provides a method to fetch new data points in response to a query. It provides an API that enables Tellor's existing decentralized reporter network to automatically respond to the query. Ideally, a DataSource should provide additional decentralization and robustness by fetching data from multiple sources and aggregating the result. A new DataSource is created by proposing changes to the telliot-feed-examples repository .","title":"Step 3: Query Data Sources"},{"location":"new-query/#defining-new-query-types","text":"If none of the existing Tellor Query Types works for your application, you can define a new Query Type . A new Query Type definition specifies: The name of the query type The data type or structure of the value expected query response (i.e. its ValueType ) Optionally, the name and data type of each query parameter Encoding method - the method used to encode the Query Type and parameter values into the query_data field used for Tellor contract interactions. It is important to note the difference between defining a Query Type and a defining a query . Defining a new Query Type creates an entire new class of queries, whereas defining a new query refers to an instance of a QueryType with the value of each parameter specified. To define a new Query Type, propose changes to the telliot-core repository defining a new subclass of OracleQuery that implements all required methods and properties. New users may choose between subclassing JsonQuery and the AbiQuery . These queries are identical in every way except for the coder/decoder that converts between the query name/parameters and the query data field used in contract interfaces. The latter format is recommended if on-chain read/write access to parameter values is required. You'll also need to create a test file for your new Query Type . To get the query_data and query_id in hex format, open up a Python shell and enter the following. We'll be using the [ Snapshot ] query as an example. from telliot_core.queries.snapshot import Snapshot q = Snapshot ( proposal_id = \"QmbZ6cYVvfoKvkDX14jRcN86z6bfV135npUfhxmENjHnQ1\" ) q . query_data q . query_id . hex ()","title":"Defining New Query Types"},{"location":"new-query/#propose-changes","text":"To propose changes to a Tellor repository, perform the following steps: Fork the tellor repository to your github account. Follow our developer's guide and make the proposed changes in your forked repository. Submit a pull-request to incorporate the changes from your fork into the main tellor repository. Alternately, standalone changes can be proposed in a separate repository, but it is the user's responsibility to ensure compatibility with the telliot-core framework.","title":"Propose changes"},{"location":"new-query/#example-adding-a-new-spotprice","text":"In this example, a new SpotPrice query is defined for the price of BTC in USD. To add a new spot price, use the existing SpotPrice Query Type and simply define a new asset / currency pair. Example: Create and test the SpotPrice query for BTC/USD. from telliot_core.api import SpotPrice def test_new_query (): q = SpotPrice ( asset = \"BTC\" , currency = \"USD\" ) assert q . descriptor == '{\"type\":\"SpotPrice\",\"asset\":\"btc\",\"currency\":\"usd\"}' assert q . query_data == b '{\"type\":\"SpotPrice\",\"asset\":\"btc\",\"currency\":\"usd\"}' assert q . query_id . hex () == \"d66b36afdec822c56014e56f468dee7c7b082ed873aba0f7663ec7c6f25d2c0a\" Example: Add the query to the Query Catalog Add the following statements to telliot_core.data.query_catalog.py . query_catalog . add_entry ( tag = \"btc-usd-spot\" , title = \"BTC/USD spot price\" , q = SpotPrice ( asset = \"BTC\" , currency = \"USD\" ) )","title":"Example: Adding a new SpotPrice"},{"location":"code/datafeed/","text":"DataSource ( Generic , Base ) dataclass \u00b6 Base Class for a DataSource A DataSource provides an input to a DataFeed It also contains a store for all previously fetched data points. All subclasses must implement DataSource.fetch_new_datapoint() Source code in telliot_core/datasource.py @dataclass class DataSource ( Generic [ T ], Base ): \"\"\"Base Class for a DataSource A DataSource provides an input to a `DataFeed` It also contains a store for all previously fetched data points. All subclasses must implement `DataSource.fetch_new_datapoint()` \"\"\" max_datapoints : int = 256 # Private storage for fetched values _history : Deque [ DataPoint [ T ]] = field ( default_factory = deque , init = False , repr = False ) def __post_init__ ( self ) -> None : # Overwrite default deque self . _history = deque ( maxlen = self . max_datapoints ) @property def latest ( self ) -> OptionalDataPoint [ T ]: \"\"\"Returns the most recent datapoint or none if history is empty\"\"\" if len ( self . _history ) >= 1 : return self . _history [ - 1 ] else : return None , None def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint ) def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history ) async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError @property def depth ( self ) -> int : return len ( self . _history ) latest : Tuple [ Optional [ ~ T ], Optional [ datetime . datetime ]] property readonly \u00b6 Returns the most recent datapoint or none if history is empty store_datapoint ( self , datapoint ) \u00b6 Store a datapoint Source code in telliot_core/datasource.py def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint ) get_all_datapoints ( self ) \u00b6 Get a list of all available data points Source code in telliot_core/datasource.py def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history ) fetch_new_datapoint ( self ) async \u00b6 Fetch new value and store it for later retrieval Source code in telliot_core/datasource.py async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError DataFeed ( Generic , Base ) dataclass \u00b6 Data feed providing query response A data feed contains a DataSource to fetch values in response to an OracleQuery . Attributes: Name Type Description query OracleQuery The Query that this feed responds to source telliot_core.datasource.DataSource[~T] Data source for feed Source code in telliot_core/datafeed.py @dataclass class DataFeed ( Generic [ T ], Base ): \"\"\"Data feed providing query response A data feed contains a DataSource to fetch values in response to an `OracleQuery`. Attributes: query: The Query that this feed responds to source: Data source for feed \"\"\" query : OracleQuery source : DataSource [ T ]","title":"Data Feed Module"},{"location":"code/datafeed/#telliot_core.datasource.DataSource","text":"Base Class for a DataSource A DataSource provides an input to a DataFeed It also contains a store for all previously fetched data points. All subclasses must implement DataSource.fetch_new_datapoint() Source code in telliot_core/datasource.py @dataclass class DataSource ( Generic [ T ], Base ): \"\"\"Base Class for a DataSource A DataSource provides an input to a `DataFeed` It also contains a store for all previously fetched data points. All subclasses must implement `DataSource.fetch_new_datapoint()` \"\"\" max_datapoints : int = 256 # Private storage for fetched values _history : Deque [ DataPoint [ T ]] = field ( default_factory = deque , init = False , repr = False ) def __post_init__ ( self ) -> None : # Overwrite default deque self . _history = deque ( maxlen = self . max_datapoints ) @property def latest ( self ) -> OptionalDataPoint [ T ]: \"\"\"Returns the most recent datapoint or none if history is empty\"\"\" if len ( self . _history ) >= 1 : return self . _history [ - 1 ] else : return None , None def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint ) def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history ) async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError @property def depth ( self ) -> int : return len ( self . _history )","title":"DataSource"},{"location":"code/datafeed/#telliot_core.datasource.DataSource.latest","text":"Returns the most recent datapoint or none if history is empty","title":"latest"},{"location":"code/datafeed/#telliot_core.datasource.DataSource.store_datapoint","text":"Store a datapoint Source code in telliot_core/datasource.py def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint )","title":"store_datapoint()"},{"location":"code/datafeed/#telliot_core.datasource.DataSource.get_all_datapoints","text":"Get a list of all available data points Source code in telliot_core/datasource.py def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history )","title":"get_all_datapoints()"},{"location":"code/datafeed/#telliot_core.datasource.DataSource.fetch_new_datapoint","text":"Fetch new value and store it for later retrieval Source code in telliot_core/datasource.py async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError","title":"fetch_new_datapoint()"},{"location":"code/datafeed/#telliot_core.datafeed.DataFeed","text":"Data feed providing query response A data feed contains a DataSource to fetch values in response to an OracleQuery . Attributes: Name Type Description query OracleQuery The Query that this feed responds to source telliot_core.datasource.DataSource[~T] Data source for feed Source code in telliot_core/datafeed.py @dataclass class DataFeed ( Generic [ T ], Base ): \"\"\"Data feed providing query response A data feed contains a DataSource to fetch values in response to an `OracleQuery`. Attributes: query: The Query that this feed responds to source: Data source for feed \"\"\" query : OracleQuery source : DataSource [ T ]","title":"DataFeed"},{"location":"code/dtypes/","text":"ValueType ( Serializable ) dataclass \u00b6 Value Type A ValueType specifies the data structure of value included in the TellorX.Oracle.submitValue() used in response to tip request. The type is specified per eth-abi grammar, i.e. https://eth-abi.readthedocs.io/en/latest/grammar.html Source code in telliot_core/dtypes/value_type.py @dataclass class ValueType ( Serializable ): \"\"\"Value Type A ValueType specifies the data structure of ``value`` included in the ``TellorX.Oracle.submitValue()`` used in response to tip request. The type is specified per eth-abi grammar, i.e. - https://eth-abi.readthedocs.io/en/latest/grammar.html \"\"\" # ABI Encoding type string abi_type : str = \"uint256\" #: True if the value should be encoded using packed bytes format. packed : bool = False def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value ) def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val ) # @validator(\"abi_type\") # def require_valid_grammar(cls, v: str) -> str: # \"\"\"A validator to require well formed ABI type string grammar.\"\"\" # t = eth_abi.grammar.parse(v) # t.validate() # return eth_abi.grammar.normalize(v) # type: ignore # # def json(self, **kwargs: Any) -> str: # \"\"\"Return compact json format used in query descriptor\"\"\" # # return super().json(**kwargs, separators=(\",\", \":\")) encode ( self , value ) \u00b6 Encode a value using the ABI Type string. Source code in telliot_core/dtypes/value_type.py def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value ) decode ( self , bytes_val ) \u00b6 Decode bytes into a value using abi type string. Source code in telliot_core/dtypes/value_type.py def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val ) UnsignedFloatType ( ValueType ) dataclass \u00b6 Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. Source code in telliot_core/dtypes/float_type.py @dataclass class UnsignedFloatType ( ValueType ): \"\"\"Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. \"\"\" #: ABI Encoding for Unsigned Float value (default = ufixed256x6) abi_type : str = \"ufixed256x6\" @property def decimals ( self ) -> int : \"\"\"Get precision from abi type\"\"\" mxn = self . abi_type [ 6 :] m , n = mxn . split ( \"x\" ) return int ( n ) @property def nbits ( self ) -> int : \"\"\"Get number of bits from abi type\"\"\" mxn = self . abi_type [ 6 :] m , n = mxn . split ( \"x\" ) return int ( m ) def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value ) def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals decimals : int property readonly \u00b6 Get precision from abi type nbits : int property readonly \u00b6 Get number of bits from abi type encode ( self , value ) \u00b6 An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. Source code in telliot_core/dtypes/float_type.py def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value ) decode ( self , bytes_val ) \u00b6 A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. Source code in telliot_core/dtypes/float_type.py def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals","title":"Types Module"},{"location":"code/dtypes/#telliot_core.dtypes.value_type.ValueType","text":"Value Type A ValueType specifies the data structure of value included in the TellorX.Oracle.submitValue() used in response to tip request. The type is specified per eth-abi grammar, i.e. https://eth-abi.readthedocs.io/en/latest/grammar.html Source code in telliot_core/dtypes/value_type.py @dataclass class ValueType ( Serializable ): \"\"\"Value Type A ValueType specifies the data structure of ``value`` included in the ``TellorX.Oracle.submitValue()`` used in response to tip request. The type is specified per eth-abi grammar, i.e. - https://eth-abi.readthedocs.io/en/latest/grammar.html \"\"\" # ABI Encoding type string abi_type : str = \"uint256\" #: True if the value should be encoded using packed bytes format. packed : bool = False def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value ) def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val ) # @validator(\"abi_type\") # def require_valid_grammar(cls, v: str) -> str: # \"\"\"A validator to require well formed ABI type string grammar.\"\"\" # t = eth_abi.grammar.parse(v) # t.validate() # return eth_abi.grammar.normalize(v) # type: ignore # # def json(self, **kwargs: Any) -> str: # \"\"\"Return compact json format used in query descriptor\"\"\" # # return super().json(**kwargs, separators=(\",\", \":\"))","title":"ValueType"},{"location":"code/dtypes/#telliot_core.dtypes.value_type.ValueType.encode","text":"Encode a value using the ABI Type string. Source code in telliot_core/dtypes/value_type.py def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value )","title":"encode()"},{"location":"code/dtypes/#telliot_core.dtypes.value_type.ValueType.decode","text":"Decode bytes into a value using abi type string. Source code in telliot_core/dtypes/value_type.py def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val )","title":"decode()"},{"location":"code/dtypes/#telliot_core.dtypes.float_type.UnsignedFloatType","text":"Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. Source code in telliot_core/dtypes/float_type.py @dataclass class UnsignedFloatType ( ValueType ): \"\"\"Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. \"\"\" #: ABI Encoding for Unsigned Float value (default = ufixed256x6) abi_type : str = \"ufixed256x6\" @property def decimals ( self ) -> int : \"\"\"Get precision from abi type\"\"\" mxn = self . abi_type [ 6 :] m , n = mxn . split ( \"x\" ) return int ( n ) @property def nbits ( self ) -> int : \"\"\"Get number of bits from abi type\"\"\" mxn = self . abi_type [ 6 :] m , n = mxn . split ( \"x\" ) return int ( m ) def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value ) def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals","title":"UnsignedFloatType"},{"location":"code/dtypes/#telliot_core.dtypes.float_type.UnsignedFloatType.decimals","text":"Get precision from abi type","title":"decimals"},{"location":"code/dtypes/#telliot_core.dtypes.float_type.UnsignedFloatType.nbits","text":"Get number of bits from abi type","title":"nbits"},{"location":"code/dtypes/#telliot_core.dtypes.float_type.UnsignedFloatType.encode","text":"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. Source code in telliot_core/dtypes/float_type.py def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value )","title":"encode()"},{"location":"code/dtypes/#telliot_core.dtypes.float_type.UnsignedFloatType.decode","text":"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. Source code in telliot_core/dtypes/float_type.py def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals","title":"decode()"},{"location":"code/query-base-classes/","text":"OracleQuery ( Serializable ) \u00b6 Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent a parameter that can be used to customize the query. The base class provides: Generation of the query descriptor JSON string. This string provides a simple platform and language independent way to identify a query. Calculation of the id field from query_data . This value is used for the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. Subclasses must provide: Encoding of the descriptor string to compute the query_data attribute, which is used for the data field of a TellorX.Oracle.tipQuery() contract call. Source code in telliot_core/queries/query.py class OracleQuery ( Serializable ): \"\"\"Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent a parameter that can be used to customize the query. The base class provides: - Generation of the query `descriptor` JSON string. This string provides a simple platform and language independent way to identify a query. - Calculation of the `id` field from `query_data`. This value is used for the `TellorX.Oracle.tipQuery()` and `TellorX.Oracle.submitValue()` contract calls. Subclasses must provide: - Encoding of the `descriptor` string to compute the `query_data` attribute, which is used for the `data` field of a `TellorX.Oracle.tipQuery()` contract call. \"\"\" @property def value_type ( self ) -> ValueType : \"\"\"Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the ``value`` submitted to the contract through ``TellorX.Oracle.submitValue()`` This method *must* be implemented by subclasses \"\"\" raise NotImplementedError @property def descriptor ( self ) -> str : \"\"\"Get the query descriptor string. The Query descriptor is a unique string representation of the query, including all parameter values. The string must be in valid JSON format (http://www.json.org). \"\"\" state = self . get_state () json_str = json . dumps ( state , separators = ( \",\" , \":\" )) return json_str @property def query_id ( self ) -> bytes : \"\"\"Returns the query ``id`` for use with the ``TellorX.Oracle.tipQuery()`` and ``TellorX.Oracle.submitValue()`` contract calls. \"\"\" return bytes ( Web3 . keccak ( self . query_data )) @property def query_data ( self ) -> bytes : \"\"\"Encode the query `descriptor` to create the query `data` field for use in the ``TellorX.Oracle.tipQuery()`` contract call. This method *must* be implemented by subclasses \"\"\" raise NotImplementedError @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" raise NotImplementedError value_type : ValueType property readonly \u00b6 Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the value submitted to the contract through TellorX.Oracle.submitValue() This method must be implemented by subclasses descriptor : str property readonly \u00b6 Get the query descriptor string. The Query descriptor is a unique string representation of the query, including all parameter values. The string must be in valid JSON format (http://www.json.org). query_id : bytes property readonly \u00b6 Returns the query id for use with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. query_data : bytes property readonly \u00b6 Encode the query descriptor to create the query data field for use in the TellorX.Oracle.tipQuery() contract call. This method must be implemented by subclasses get_query_from_data ( query_data ) staticmethod \u00b6 Recreate an oracle query from query_data Source code in telliot_core/queries/query.py @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" raise NotImplementedError JsonQuery ( OracleQuery ) \u00b6 An Oracle Query that uses JSON-encoding to compute the query_data. Source code in telliot_core/queries/json_query.py class JsonQuery ( OracleQuery ): \"\"\"An Oracle Query that uses JSON-encoding to compute the query_data.\"\"\" @property def query_data ( self ) -> bytes : \"\"\"Encode the query `descriptor` to create the query `data` field for use in the ``TellorX.Oracle.tipQuery()`` contract call. \"\"\" return self . descriptor . encode ( \"utf-8\" ) @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" descriptor = query_data . decode ( \"utf-8\" ) return query_from_descriptor ( descriptor ) query_data : bytes property readonly \u00b6 Encode the query descriptor to create the query data field for use in the TellorX.Oracle.tipQuery() contract call. get_query_from_data ( query_data ) staticmethod \u00b6 Recreate an oracle query from query_data Source code in telliot_core/queries/json_query.py @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" descriptor = query_data . decode ( \"utf-8\" ) return query_from_descriptor ( descriptor ) AbiQuery ( OracleQuery ) \u00b6 An Oracle Query that uses ABI-encoding to compute the query_data. Attributes: Name Type Description abi ClassVar[list[dict[str, str]]] The ABI used for encoding/decoding parameters. Each subclass must defind the ABI. The ABI is an ordered list, with one entry for each query parameter. Each parameter should include a dict with two entries: {\"name\": , \"type\": } Parameter types must be valid solidity ABI type string. See https://docs.soliditylang.org/en/develop/types.html for reference. Source code in telliot_core/queries/abi_query.py class AbiQuery ( OracleQuery ): \"\"\"An Oracle Query that uses ABI-encoding to compute the query_data. Attributes: abi: The ABI used for encoding/decoding parameters. Each subclass must defind the ABI. The ABI is an ordered list, with one entry for each query parameter. Each parameter should include a dict with two entries: {\"name\": <parameter name>, \"type\": <parameter type>} Parameter types must be valid solidity ABI type string. See https://docs.soliditylang.org/en/develop/types.html for reference. \"\"\" abi : ClassVar [ list [ dict [ str , str ]]] = [] @property def query_data ( self ) -> bytes : \"\"\"Encode the query type and parameters to create the query data. This method uses ABI encoding to encode the query's parameter values. \"\"\" param_values = [ getattr ( self , p [ \"name\" ]) for p in self . abi ] param_types = [ p [ \"type\" ] for p in self . abi ] encoded_params = encode_abi ( param_types , param_values ) return encode_abi ([ \"string\" , \"bytes\" ], [ type ( self ) . __name__ , encoded_params ]) @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from the `query_data` field\"\"\" query_type , encoded_param_values = decode_abi ([ \"string\" , \"bytes\" ], query_data ) cls = Registry . registry [ query_type ] params_abi = cls . abi param_names = [ p [ \"name\" ] for p in params_abi ] param_types = [ p [ \"type\" ] for p in params_abi ] param_values = decode_abi ( param_types , encoded_param_values ) params = dict ( zip ( param_names , param_values )) return deserialize ({ \"type\" : query_type , ** params }) # type: ignore query_data : bytes property readonly \u00b6 Encode the query type and parameters to create the query data. This method uses ABI encoding to encode the query's parameter values. get_query_from_data ( query_data ) staticmethod \u00b6 Recreate an oracle query from the query_data field Source code in telliot_core/queries/abi_query.py @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from the `query_data` field\"\"\" query_type , encoded_param_values = decode_abi ([ \"string\" , \"bytes\" ], query_data ) cls = Registry . registry [ query_type ] params_abi = cls . abi param_names = [ p [ \"name\" ] for p in params_abi ] param_types = [ p [ \"type\" ] for p in params_abi ] param_values = decode_abi ( param_types , encoded_param_values ) params = dict ( zip ( param_names , param_values )) return deserialize ({ \"type\" : query_type , ** params }) # type: ignore","title":"Query Base Classes"},{"location":"code/query-base-classes/#telliot_core.queries.query.OracleQuery","text":"Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent a parameter that can be used to customize the query. The base class provides: Generation of the query descriptor JSON string. This string provides a simple platform and language independent way to identify a query. Calculation of the id field from query_data . This value is used for the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. Subclasses must provide: Encoding of the descriptor string to compute the query_data attribute, which is used for the data field of a TellorX.Oracle.tipQuery() contract call. Source code in telliot_core/queries/query.py class OracleQuery ( Serializable ): \"\"\"Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent a parameter that can be used to customize the query. The base class provides: - Generation of the query `descriptor` JSON string. This string provides a simple platform and language independent way to identify a query. - Calculation of the `id` field from `query_data`. This value is used for the `TellorX.Oracle.tipQuery()` and `TellorX.Oracle.submitValue()` contract calls. Subclasses must provide: - Encoding of the `descriptor` string to compute the `query_data` attribute, which is used for the `data` field of a `TellorX.Oracle.tipQuery()` contract call. \"\"\" @property def value_type ( self ) -> ValueType : \"\"\"Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the ``value`` submitted to the contract through ``TellorX.Oracle.submitValue()`` This method *must* be implemented by subclasses \"\"\" raise NotImplementedError @property def descriptor ( self ) -> str : \"\"\"Get the query descriptor string. The Query descriptor is a unique string representation of the query, including all parameter values. The string must be in valid JSON format (http://www.json.org). \"\"\" state = self . get_state () json_str = json . dumps ( state , separators = ( \",\" , \":\" )) return json_str @property def query_id ( self ) -> bytes : \"\"\"Returns the query ``id`` for use with the ``TellorX.Oracle.tipQuery()`` and ``TellorX.Oracle.submitValue()`` contract calls. \"\"\" return bytes ( Web3 . keccak ( self . query_data )) @property def query_data ( self ) -> bytes : \"\"\"Encode the query `descriptor` to create the query `data` field for use in the ``TellorX.Oracle.tipQuery()`` contract call. This method *must* be implemented by subclasses \"\"\" raise NotImplementedError @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" raise NotImplementedError","title":"OracleQuery"},{"location":"code/query-base-classes/#telliot_core.queries.query.OracleQuery.value_type","text":"Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the value submitted to the contract through TellorX.Oracle.submitValue() This method must be implemented by subclasses","title":"value_type"},{"location":"code/query-base-classes/#telliot_core.queries.query.OracleQuery.descriptor","text":"Get the query descriptor string. The Query descriptor is a unique string representation of the query, including all parameter values. The string must be in valid JSON format (http://www.json.org).","title":"descriptor"},{"location":"code/query-base-classes/#telliot_core.queries.query.OracleQuery.query_id","text":"Returns the query id for use with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls.","title":"query_id"},{"location":"code/query-base-classes/#telliot_core.queries.query.OracleQuery.query_data","text":"Encode the query descriptor to create the query data field for use in the TellorX.Oracle.tipQuery() contract call. This method must be implemented by subclasses","title":"query_data"},{"location":"code/query-base-classes/#telliot_core.queries.query.OracleQuery.get_query_from_data","text":"Recreate an oracle query from query_data Source code in telliot_core/queries/query.py @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" raise NotImplementedError","title":"get_query_from_data()"},{"location":"code/query-base-classes/#telliot_core.queries.json_query.JsonQuery","text":"An Oracle Query that uses JSON-encoding to compute the query_data. Source code in telliot_core/queries/json_query.py class JsonQuery ( OracleQuery ): \"\"\"An Oracle Query that uses JSON-encoding to compute the query_data.\"\"\" @property def query_data ( self ) -> bytes : \"\"\"Encode the query `descriptor` to create the query `data` field for use in the ``TellorX.Oracle.tipQuery()`` contract call. \"\"\" return self . descriptor . encode ( \"utf-8\" ) @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" descriptor = query_data . decode ( \"utf-8\" ) return query_from_descriptor ( descriptor )","title":"JsonQuery"},{"location":"code/query-base-classes/#telliot_core.queries.json_query.JsonQuery.query_data","text":"Encode the query descriptor to create the query data field for use in the TellorX.Oracle.tipQuery() contract call.","title":"query_data"},{"location":"code/query-base-classes/#telliot_core.queries.json_query.JsonQuery.get_query_from_data","text":"Recreate an oracle query from query_data Source code in telliot_core/queries/json_query.py @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from `query_data`\"\"\" descriptor = query_data . decode ( \"utf-8\" ) return query_from_descriptor ( descriptor )","title":"get_query_from_data()"},{"location":"code/query-base-classes/#telliot_core.queries.abi_query.AbiQuery","text":"An Oracle Query that uses ABI-encoding to compute the query_data. Attributes: Name Type Description abi ClassVar[list[dict[str, str]]] The ABI used for encoding/decoding parameters. Each subclass must defind the ABI. The ABI is an ordered list, with one entry for each query parameter. Each parameter should include a dict with two entries: {\"name\": , \"type\": } Parameter types must be valid solidity ABI type string. See https://docs.soliditylang.org/en/develop/types.html for reference. Source code in telliot_core/queries/abi_query.py class AbiQuery ( OracleQuery ): \"\"\"An Oracle Query that uses ABI-encoding to compute the query_data. Attributes: abi: The ABI used for encoding/decoding parameters. Each subclass must defind the ABI. The ABI is an ordered list, with one entry for each query parameter. Each parameter should include a dict with two entries: {\"name\": <parameter name>, \"type\": <parameter type>} Parameter types must be valid solidity ABI type string. See https://docs.soliditylang.org/en/develop/types.html for reference. \"\"\" abi : ClassVar [ list [ dict [ str , str ]]] = [] @property def query_data ( self ) -> bytes : \"\"\"Encode the query type and parameters to create the query data. This method uses ABI encoding to encode the query's parameter values. \"\"\" param_values = [ getattr ( self , p [ \"name\" ]) for p in self . abi ] param_types = [ p [ \"type\" ] for p in self . abi ] encoded_params = encode_abi ( param_types , param_values ) return encode_abi ([ \"string\" , \"bytes\" ], [ type ( self ) . __name__ , encoded_params ]) @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from the `query_data` field\"\"\" query_type , encoded_param_values = decode_abi ([ \"string\" , \"bytes\" ], query_data ) cls = Registry . registry [ query_type ] params_abi = cls . abi param_names = [ p [ \"name\" ] for p in params_abi ] param_types = [ p [ \"type\" ] for p in params_abi ] param_values = decode_abi ( param_types , encoded_param_values ) params = dict ( zip ( param_names , param_values )) return deserialize ({ \"type\" : query_type , ** params }) # type: ignore","title":"AbiQuery"},{"location":"code/query-base-classes/#telliot_core.queries.abi_query.AbiQuery.query_data","text":"Encode the query type and parameters to create the query data. This method uses ABI encoding to encode the query's parameter values.","title":"query_data"},{"location":"code/query-base-classes/#telliot_core.queries.abi_query.AbiQuery.get_query_from_data","text":"Recreate an oracle query from the query_data field Source code in telliot_core/queries/abi_query.py @staticmethod def get_query_from_data ( query_data : bytes ) -> OracleQuery : \"\"\"Recreate an oracle query from the `query_data` field\"\"\" query_type , encoded_param_values = decode_abi ([ \"string\" , \"bytes\" ], query_data ) cls = Registry . registry [ query_type ] params_abi = cls . abi param_names = [ p [ \"name\" ] for p in params_abi ] param_types = [ p [ \"type\" ] for p in params_abi ] param_values = decode_abi ( param_types , encoded_param_values ) params = dict ( zip ( param_names , param_values )) return deserialize ({ \"type\" : query_type , ** params }) # type: ignore","title":"get_query_from_data()"},{"location":"code/query-catalog/","text":"Catalog ( Base ) dataclass \u00b6 Query Catalog The query catalog contains one CatalogEntry object for each valid query in the Tellor network. It is stored as a mapping of query names (i.e. tags) to CatalogEntry objects. Source code in telliot_core/queries/catalog.py @dataclass class Catalog ( Base ): \"\"\"Query Catalog The query catalog contains one `CatalogEntry` object for each valid query in the Tellor network. It is stored as a mapping of query names (i.e. tags) to `CatalogEntry` objects. \"\"\" _entries : Dict [ str , CatalogEntry ] = field ( default_factory = dict ) def add_entry ( self , tag : str , title : str , q : OracleQuery , active : bool = True ) -> None : \"\"\"Add a new entry to the catalog.\"\"\" if tag in self . _entries : raise Exception ( f \"Error adding query entry: { tag } already exists\" ) if isinstance ( q , AbiQuery ): abi = json . dumps ( q . abi ) else : abi = \"\" entry = CatalogEntry ( tag = tag , title = title , query_type = q . __class__ . __name__ , descriptor = q . descriptor , query_id = f \"0x { q . query_id . hex () } \" , active = active , abi = abi , ) self . _entries [ tag ] = entry def find ( self , * , tag : Optional [ str ] = None , query_id : Optional [ str ] = None , query_type : Optional [ str ] = None , active : Optional [ bool ] = None , ) -> List [ OracleQuery ]: \"\"\"Search the query catalog for matching entries.\"\"\" entries = [] for entry in self . _entries . values (): if tag is not None : if tag not in entry . tag : # includes search for substring continue if query_id is not None : # Add 0x if necessary for match if query_id [: 2 ] not in [ \"0x\" , \"0X\" ]: query_id = \"0x\" + query_id if query_id . lower () != entry . query_id . lower (): continue if query_type is not None : if query_type . lower () != entry . query_type . lower (): continue if active is not None : if active != entry . active : continue entries . append ( entry ) return entries def to_yaml ( self ) -> str : all_entries = self . find () return yaml . dump ( clamfig . serialize ( all_entries ), sort_keys = False ) # type: ignore def to_markdown ( self ) -> str : lines = [ \"# TellorX Query Catalog\" , \"\" ] for entry in self . find (): lines . append ( f \"## { entry . title } \" ) lines . append ( \"\" ) lines . append ( \"| Parameter | Value |\" ) lines . append ( \"| --- | --- |\" ) lines . append ( f \"| Tag | ` { entry . tag } ` |\" ) lines . append ( f \"| Active | ` { entry . active } ` |\" ) lines . append ( f \"| Type | ` { entry . query_type } ` |\" ) lines . append ( f \"| Descriptor | ` { entry . descriptor } ` |\" ) lines . append ( f \"| Encoding ABI | ` { entry . abi } ` |\" ) lines . append ( f \"| Query ID | ` { entry . query_id } ` |\" ) # type: ignore lines . append ( f \"| Query data | `0x { entry . query . query_data . hex () } ` |\" ) lines . append ( \"\" ) return \" \\n \" . join ( lines ) add_entry ( self , tag , title , q , active = True ) \u00b6 Add a new entry to the catalog. Source code in telliot_core/queries/catalog.py def add_entry ( self , tag : str , title : str , q : OracleQuery , active : bool = True ) -> None : \"\"\"Add a new entry to the catalog.\"\"\" if tag in self . _entries : raise Exception ( f \"Error adding query entry: { tag } already exists\" ) if isinstance ( q , AbiQuery ): abi = json . dumps ( q . abi ) else : abi = \"\" entry = CatalogEntry ( tag = tag , title = title , query_type = q . __class__ . __name__ , descriptor = q . descriptor , query_id = f \"0x { q . query_id . hex () } \" , active = active , abi = abi , ) self . _entries [ tag ] = entry find ( self , * , tag = None , query_id = None , query_type = None , active = None ) \u00b6 Search the query catalog for matching entries. Source code in telliot_core/queries/catalog.py def find ( self , * , tag : Optional [ str ] = None , query_id : Optional [ str ] = None , query_type : Optional [ str ] = None , active : Optional [ bool ] = None , ) -> List [ OracleQuery ]: \"\"\"Search the query catalog for matching entries.\"\"\" entries = [] for entry in self . _entries . values (): if tag is not None : if tag not in entry . tag : # includes search for substring continue if query_id is not None : # Add 0x if necessary for match if query_id [: 2 ] not in [ \"0x\" , \"0X\" ]: query_id = \"0x\" + query_id if query_id . lower () != entry . query_id . lower (): continue if query_type is not None : if query_type . lower () != entry . query_type . lower (): continue if active is not None : if active != entry . active : continue entries . append ( entry ) return entries CatalogEntry ( Base ) dataclass \u00b6 Query Catalog Entry An entry in the query Catalog containing relevant information about the query Source code in telliot_core/queries/catalog.py @dataclass class CatalogEntry ( Base ): \"\"\"Query Catalog Entry An entry in the query Catalog containing relevant information about the query \"\"\" #: Catalog ID tag : str title : str query_type : str descriptor : str query_id : str active : bool abi : str @property def query ( self ) -> OracleQuery : \"\"\"Return query object corresponding to catalog entry\"\"\" state = json . loads ( self . descriptor ) return clamfig . deserialize ( state ) # type: ignore query : OracleQuery property readonly \u00b6 Return query object corresponding to catalog entry","title":"Query Catalog"},{"location":"code/query-catalog/#telliot_core.queries.catalog.Catalog","text":"Query Catalog The query catalog contains one CatalogEntry object for each valid query in the Tellor network. It is stored as a mapping of query names (i.e. tags) to CatalogEntry objects. Source code in telliot_core/queries/catalog.py @dataclass class Catalog ( Base ): \"\"\"Query Catalog The query catalog contains one `CatalogEntry` object for each valid query in the Tellor network. It is stored as a mapping of query names (i.e. tags) to `CatalogEntry` objects. \"\"\" _entries : Dict [ str , CatalogEntry ] = field ( default_factory = dict ) def add_entry ( self , tag : str , title : str , q : OracleQuery , active : bool = True ) -> None : \"\"\"Add a new entry to the catalog.\"\"\" if tag in self . _entries : raise Exception ( f \"Error adding query entry: { tag } already exists\" ) if isinstance ( q , AbiQuery ): abi = json . dumps ( q . abi ) else : abi = \"\" entry = CatalogEntry ( tag = tag , title = title , query_type = q . __class__ . __name__ , descriptor = q . descriptor , query_id = f \"0x { q . query_id . hex () } \" , active = active , abi = abi , ) self . _entries [ tag ] = entry def find ( self , * , tag : Optional [ str ] = None , query_id : Optional [ str ] = None , query_type : Optional [ str ] = None , active : Optional [ bool ] = None , ) -> List [ OracleQuery ]: \"\"\"Search the query catalog for matching entries.\"\"\" entries = [] for entry in self . _entries . values (): if tag is not None : if tag not in entry . tag : # includes search for substring continue if query_id is not None : # Add 0x if necessary for match if query_id [: 2 ] not in [ \"0x\" , \"0X\" ]: query_id = \"0x\" + query_id if query_id . lower () != entry . query_id . lower (): continue if query_type is not None : if query_type . lower () != entry . query_type . lower (): continue if active is not None : if active != entry . active : continue entries . append ( entry ) return entries def to_yaml ( self ) -> str : all_entries = self . find () return yaml . dump ( clamfig . serialize ( all_entries ), sort_keys = False ) # type: ignore def to_markdown ( self ) -> str : lines = [ \"# TellorX Query Catalog\" , \"\" ] for entry in self . find (): lines . append ( f \"## { entry . title } \" ) lines . append ( \"\" ) lines . append ( \"| Parameter | Value |\" ) lines . append ( \"| --- | --- |\" ) lines . append ( f \"| Tag | ` { entry . tag } ` |\" ) lines . append ( f \"| Active | ` { entry . active } ` |\" ) lines . append ( f \"| Type | ` { entry . query_type } ` |\" ) lines . append ( f \"| Descriptor | ` { entry . descriptor } ` |\" ) lines . append ( f \"| Encoding ABI | ` { entry . abi } ` |\" ) lines . append ( f \"| Query ID | ` { entry . query_id } ` |\" ) # type: ignore lines . append ( f \"| Query data | `0x { entry . query . query_data . hex () } ` |\" ) lines . append ( \"\" ) return \" \\n \" . join ( lines )","title":"Catalog"},{"location":"code/query-catalog/#telliot_core.queries.catalog.Catalog.add_entry","text":"Add a new entry to the catalog. Source code in telliot_core/queries/catalog.py def add_entry ( self , tag : str , title : str , q : OracleQuery , active : bool = True ) -> None : \"\"\"Add a new entry to the catalog.\"\"\" if tag in self . _entries : raise Exception ( f \"Error adding query entry: { tag } already exists\" ) if isinstance ( q , AbiQuery ): abi = json . dumps ( q . abi ) else : abi = \"\" entry = CatalogEntry ( tag = tag , title = title , query_type = q . __class__ . __name__ , descriptor = q . descriptor , query_id = f \"0x { q . query_id . hex () } \" , active = active , abi = abi , ) self . _entries [ tag ] = entry","title":"add_entry()"},{"location":"code/query-catalog/#telliot_core.queries.catalog.Catalog.find","text":"Search the query catalog for matching entries. Source code in telliot_core/queries/catalog.py def find ( self , * , tag : Optional [ str ] = None , query_id : Optional [ str ] = None , query_type : Optional [ str ] = None , active : Optional [ bool ] = None , ) -> List [ OracleQuery ]: \"\"\"Search the query catalog for matching entries.\"\"\" entries = [] for entry in self . _entries . values (): if tag is not None : if tag not in entry . tag : # includes search for substring continue if query_id is not None : # Add 0x if necessary for match if query_id [: 2 ] not in [ \"0x\" , \"0X\" ]: query_id = \"0x\" + query_id if query_id . lower () != entry . query_id . lower (): continue if query_type is not None : if query_type . lower () != entry . query_type . lower (): continue if active is not None : if active != entry . active : continue entries . append ( entry ) return entries","title":"find()"},{"location":"code/query-catalog/#telliot_core.queries.catalog.CatalogEntry","text":"Query Catalog Entry An entry in the query Catalog containing relevant information about the query Source code in telliot_core/queries/catalog.py @dataclass class CatalogEntry ( Base ): \"\"\"Query Catalog Entry An entry in the query Catalog containing relevant information about the query \"\"\" #: Catalog ID tag : str title : str query_type : str descriptor : str query_id : str active : bool abi : str @property def query ( self ) -> OracleQuery : \"\"\"Return query object corresponding to catalog entry\"\"\" state = json . loads ( self . descriptor ) return clamfig . deserialize ( state ) # type: ignore","title":"CatalogEntry"},{"location":"code/query-catalog/#telliot_core.queries.catalog.CatalogEntry.query","text":"Return query object corresponding to catalog entry","title":"query"},{"location":"code/query-types/","text":"SpotPrice ( AbiQuery ) dataclass \u00b6 Returns the spot price of a cryptocurrency asset in the given currency. Attributes: Name Type Description asset str Asset ID (see data specifications for a full list of supported assets) currency str Currency (default = usd ) Source code in telliot_core/queries/price/spot_price.py @dataclass class SpotPrice ( AbiQuery ): \"\"\"Returns the spot price of a cryptocurrency asset in the given currency. Attributes: asset: Asset ID (see data specifications for a full list of supported assets) currency: Currency (default = `usd`) \"\"\" asset : str currency : str #: ABI used for encoding/decoding parameters abi = [{ \"name\" : \"asset\" , \"type\" : \"string\" }, { \"name\" : \"currency\" , \"type\" : \"string\" }] @property def value_type ( self ) -> ValueType : \"\"\"Data type returned for a SpotPrice query. - `ufixed256x18`: 256-bit unsigned integer with 18 decimals of precision - `packed`: false \"\"\" return UnsignedFloatType ( abi_type = \"ufixed256x18\" , packed = False ) def __post_init__ ( self ) -> None : \"\"\"Validate parameters.\"\"\" self . asset = self . asset . lower () self . currency = self . currency . lower () if self . currency not in currencies : raise ValueError ( f \"currency { self . currency } not supported\" ) if ( self . asset , self . currency ) not in spot_price_pairs : raise ValueError ( f \" { self . asset } / { self . currency } is not a supported pair\" ) value_type : ValueType property readonly \u00b6 Data type returned for a SpotPrice query. ufixed256x18 : 256-bit unsigned integer with 18 decimals of precision packed : false __post_init__ ( self ) special \u00b6 Validate parameters. Source code in telliot_core/queries/price/spot_price.py def __post_init__ ( self ) -> None : \"\"\"Validate parameters.\"\"\" self . asset = self . asset . lower () self . currency = self . currency . lower () if self . currency not in currencies : raise ValueError ( f \"currency { self . currency } not supported\" ) if ( self . asset , self . currency ) not in spot_price_pairs : raise ValueError ( f \" { self . asset } / { self . currency } is not a supported pair\" ) LegacyRequest ( AbiQuery ) dataclass \u00b6 Legacy Price/Value request Legacy request are queries that existed prior to TellorX A legacy query uses arbitrary query data and a static query id . The query id is always set to the legacy request ID, which is a static integer less than 100. The LegacyQuery class is deprecated and should not be used by new projects. Refer to tellor documentation for a description of each id Source code in telliot_core/queries/legacy_query.py @dataclass class LegacyRequest ( AbiQuery ): \"\"\"Legacy Price/Value request Legacy request are queries that existed prior to TellorX A legacy query uses arbitrary query ``data`` and a static query ``id``. The query ``id`` is always set to the legacy request ID, which is a static integer less than 100. The LegacyQuery class is deprecated and should not be used by new projects. Refer to [tellor documentation](https://docs.tellor.io/tellor/integration/data-ids) for a description of each ``id`` \"\"\" legacy_id : int abi = [{ \"name\" : \"legacy_id\" , \"type\" : \"uint256\" }] @property def value_type ( self ) -> ValueType : if self . legacy_id in [ 10 , 41 ]: \"\"\"Returns the Legacy Value Type for AMPL legacy queries\"\"\" return UnsignedFloatType ( abi_type = \"ufixed256x18\" , packed = False ) else : \"\"\"Returns the Legacy Value Type for all other legacy queries\"\"\" return UnsignedFloatType ( abi_type = \"ufixed256x6\" , packed = False ) @property def query_id ( self ) -> bytes : \"\"\"Override query ``id`` with the legacy request ID.\"\"\" return self . legacy_id . to_bytes ( 32 , \"big\" , signed = False ) value_type : ValueType property readonly \u00b6 Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the value submitted to the contract through TellorX.Oracle.submitValue() This method must be implemented by subclasses query_id : bytes property readonly \u00b6 Override query id with the legacy request ID. StringQuery ( JsonQuery ) dataclass \u00b6 Static Oracle Query A text query supports a question in the form of an arbitrary text. Source code in telliot_core/queries/string_query.py @dataclass class StringQuery ( JsonQuery ): \"\"\"Static Oracle Query A text query supports a question in the form of an arbitrary text. \"\"\" #: Static query text text : str @property def value_type ( self ) -> ValueType : \"\"\"Returns a default text response type.\"\"\" return ValueType ( abi_type = \"string\" , packed = False ) value_type : ValueType property readonly \u00b6 Returns a default text response type.","title":"Query Types"},{"location":"code/query-types/#telliot_core.queries.price.spot_price.SpotPrice","text":"Returns the spot price of a cryptocurrency asset in the given currency. Attributes: Name Type Description asset str Asset ID (see data specifications for a full list of supported assets) currency str Currency (default = usd ) Source code in telliot_core/queries/price/spot_price.py @dataclass class SpotPrice ( AbiQuery ): \"\"\"Returns the spot price of a cryptocurrency asset in the given currency. Attributes: asset: Asset ID (see data specifications for a full list of supported assets) currency: Currency (default = `usd`) \"\"\" asset : str currency : str #: ABI used for encoding/decoding parameters abi = [{ \"name\" : \"asset\" , \"type\" : \"string\" }, { \"name\" : \"currency\" , \"type\" : \"string\" }] @property def value_type ( self ) -> ValueType : \"\"\"Data type returned for a SpotPrice query. - `ufixed256x18`: 256-bit unsigned integer with 18 decimals of precision - `packed`: false \"\"\" return UnsignedFloatType ( abi_type = \"ufixed256x18\" , packed = False ) def __post_init__ ( self ) -> None : \"\"\"Validate parameters.\"\"\" self . asset = self . asset . lower () self . currency = self . currency . lower () if self . currency not in currencies : raise ValueError ( f \"currency { self . currency } not supported\" ) if ( self . asset , self . currency ) not in spot_price_pairs : raise ValueError ( f \" { self . asset } / { self . currency } is not a supported pair\" )","title":"SpotPrice"},{"location":"code/query-types/#telliot_core.queries.price.spot_price.SpotPrice.value_type","text":"Data type returned for a SpotPrice query. ufixed256x18 : 256-bit unsigned integer with 18 decimals of precision packed : false","title":"value_type"},{"location":"code/query-types/#telliot_core.queries.price.spot_price.SpotPrice.__post_init__","text":"Validate parameters. Source code in telliot_core/queries/price/spot_price.py def __post_init__ ( self ) -> None : \"\"\"Validate parameters.\"\"\" self . asset = self . asset . lower () self . currency = self . currency . lower () if self . currency not in currencies : raise ValueError ( f \"currency { self . currency } not supported\" ) if ( self . asset , self . currency ) not in spot_price_pairs : raise ValueError ( f \" { self . asset } / { self . currency } is not a supported pair\" )","title":"__post_init__()"},{"location":"code/query-types/#telliot_core.queries.legacy_query.LegacyRequest","text":"Legacy Price/Value request Legacy request are queries that existed prior to TellorX A legacy query uses arbitrary query data and a static query id . The query id is always set to the legacy request ID, which is a static integer less than 100. The LegacyQuery class is deprecated and should not be used by new projects. Refer to tellor documentation for a description of each id Source code in telliot_core/queries/legacy_query.py @dataclass class LegacyRequest ( AbiQuery ): \"\"\"Legacy Price/Value request Legacy request are queries that existed prior to TellorX A legacy query uses arbitrary query ``data`` and a static query ``id``. The query ``id`` is always set to the legacy request ID, which is a static integer less than 100. The LegacyQuery class is deprecated and should not be used by new projects. Refer to [tellor documentation](https://docs.tellor.io/tellor/integration/data-ids) for a description of each ``id`` \"\"\" legacy_id : int abi = [{ \"name\" : \"legacy_id\" , \"type\" : \"uint256\" }] @property def value_type ( self ) -> ValueType : if self . legacy_id in [ 10 , 41 ]: \"\"\"Returns the Legacy Value Type for AMPL legacy queries\"\"\" return UnsignedFloatType ( abi_type = \"ufixed256x18\" , packed = False ) else : \"\"\"Returns the Legacy Value Type for all other legacy queries\"\"\" return UnsignedFloatType ( abi_type = \"ufixed256x6\" , packed = False ) @property def query_id ( self ) -> bytes : \"\"\"Override query ``id`` with the legacy request ID.\"\"\" return self . legacy_id . to_bytes ( 32 , \"big\" , signed = False )","title":"LegacyRequest"},{"location":"code/query-types/#telliot_core.queries.legacy_query.LegacyRequest.value_type","text":"Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the value submitted to the contract through TellorX.Oracle.submitValue() This method must be implemented by subclasses","title":"value_type"},{"location":"code/query-types/#telliot_core.queries.legacy_query.LegacyRequest.query_id","text":"Override query id with the legacy request ID.","title":"query_id"},{"location":"code/query-types/#telliot_core.queries.string_query.StringQuery","text":"Static Oracle Query A text query supports a question in the form of an arbitrary text. Source code in telliot_core/queries/string_query.py @dataclass class StringQuery ( JsonQuery ): \"\"\"Static Oracle Query A text query supports a question in the form of an arbitrary text. \"\"\" #: Static query text text : str @property def value_type ( self ) -> ValueType : \"\"\"Returns a default text response type.\"\"\" return ValueType ( abi_type = \"string\" , packed = False )","title":"StringQuery"},{"location":"code/query-types/#telliot_core.queries.string_query.StringQuery.value_type","text":"Returns a default text response type.","title":"value_type"},{"location":"examples/legacy_query_example/","text":"Legacy Query Example \u00b6 This example demonstrates how to create a LegacyRequest requesting the ETH/USD price. The legacy request ID for ETH/USD is 1 , in accordance with the Legacy Data Feed ID Specifications . Create the query \u00b6 Create a LegacyQuery and view the corresponding query descriptor: from telliot_core.api import LegacyRequest q = LegacyRequest ( legacy_id = 1 ) print ( q . descriptor ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"LegacyRequest\" , \"legacy_id\" : 1 } On-chain representation \u00b6 To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the LegacyQuery object: print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a224c656761637952657175657374222c226c65676163795f6964223a317d tipQuery ID: 0x0000000000000000000000000000000000000000000000000000000000000001 Response encoding/decoding \u00b6 The LegacyQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit the value 10000.1234567 , use the encode and decode methods of the response ValueType . value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (float): 10000.1234567 submitValue (bytes): 0x00000000000000000000000000000000000000000000000000000002540dc641 Similarly, the decode method can be used to convert the on-chain bytes value to a real-world value: decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Decoded value (float): 10000.123457 Full Example \u00b6 The full example is provided here for reference \"\"\"Legacy Query Example \"\"\" from telliot_core.api import LegacyRequest q = LegacyRequest ( legacy_id = 1 ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" )","title":"Legacy Query"},{"location":"examples/legacy_query_example/#legacy-query-example","text":"This example demonstrates how to create a LegacyRequest requesting the ETH/USD price. The legacy request ID for ETH/USD is 1 , in accordance with the Legacy Data Feed ID Specifications .","title":"Legacy Query Example"},{"location":"examples/legacy_query_example/#create-the-query","text":"Create a LegacyQuery and view the corresponding query descriptor: from telliot_core.api import LegacyRequest q = LegacyRequest ( legacy_id = 1 ) print ( q . descriptor ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"LegacyRequest\" , \"legacy_id\" : 1 }","title":"Create the query"},{"location":"examples/legacy_query_example/#on-chain-representation","text":"To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the LegacyQuery object: print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a224c656761637952657175657374222c226c65676163795f6964223a317d tipQuery ID: 0x0000000000000000000000000000000000000000000000000000000000000001","title":"On-chain representation"},{"location":"examples/legacy_query_example/#response-encodingdecoding","text":"The LegacyQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit the value 10000.1234567 , use the encode and decode methods of the response ValueType . value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (float): 10000.1234567 submitValue (bytes): 0x00000000000000000000000000000000000000000000000000000002540dc641 Similarly, the decode method can be used to convert the on-chain bytes value to a real-world value: decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Decoded value (float): 10000.123457","title":"Response encoding/decoding"},{"location":"examples/legacy_query_example/#full-example","text":"The full example is provided here for reference \"\"\"Legacy Query Example \"\"\" from telliot_core.api import LegacyRequest q = LegacyRequest ( legacy_id = 1 ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" )","title":"Full Example"},{"location":"examples/spot_price_query_example/","text":"Spot Price Query Example \u00b6 This example demonstrates how to use the SpotPrice Oracle query. Create the query \u00b6 Create a SpotPrice query for the price of Bitcoin in US dollars, and view the corresponding descriptor:: from telliot_core.api import SpotPrice q = SpotPrice ( asset = 'btc' , currency = 'usd' ) print ( q . descriptor ) The query .descriptor attribute returns a unique string that identifies this query to the TellorX Oracle network: { \"type\" : \"SpotPrice\" , \"asset\" : \"btc\" , \"currency\" : \"usd\" } On-chain representation \u00b6 To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are computed solely from the query descriptor , and are provided by the query_data and query_id attributes as a convenience. print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a2253706f745072696365222c226173736574223a22627463222c2263757272656e6379223a22757364227d tipQuery ID: 0xd66b36afdec822c56014e56f468dee7c7b082ed873aba0f7663ec7c6f25d2c0a Response encoding/decoding \u00b6 The SpotPrice query can also be used to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit the real world value 99.9 use the ValueType . encode method. value = 99.99 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) submitValue (float): 99.99 submitValue (bytes): 0x0000000000000000000000000000000000000000000000056ba3d73af34eec04 Similarly, the decode method can be used to convert the on-chain bytes value to a real-world value: decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Decoded value (float): 99.99 Full Example \u00b6 The full example is provided here for reference \"\"\"Text Query Example \"\"\" from telliot_core.api import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" )","title":"SpotPrice Query"},{"location":"examples/spot_price_query_example/#spot-price-query-example","text":"This example demonstrates how to use the SpotPrice Oracle query.","title":"Spot Price Query Example"},{"location":"examples/spot_price_query_example/#create-the-query","text":"Create a SpotPrice query for the price of Bitcoin in US dollars, and view the corresponding descriptor:: from telliot_core.api import SpotPrice q = SpotPrice ( asset = 'btc' , currency = 'usd' ) print ( q . descriptor ) The query .descriptor attribute returns a unique string that identifies this query to the TellorX Oracle network: { \"type\" : \"SpotPrice\" , \"asset\" : \"btc\" , \"currency\" : \"usd\" }","title":"Create the query"},{"location":"examples/spot_price_query_example/#on-chain-representation","text":"To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are computed solely from the query descriptor , and are provided by the query_data and query_id attributes as a convenience. print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a2253706f745072696365222c226173736574223a22627463222c2263757272656e6379223a22757364227d tipQuery ID: 0xd66b36afdec822c56014e56f468dee7c7b082ed873aba0f7663ec7c6f25d2c0a","title":"On-chain representation"},{"location":"examples/spot_price_query_example/#response-encodingdecoding","text":"The SpotPrice query can also be used to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit the real world value 99.9 use the ValueType . encode method. value = 99.99 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) submitValue (float): 99.99 submitValue (bytes): 0x0000000000000000000000000000000000000000000000056ba3d73af34eec04 Similarly, the decode method can be used to convert the on-chain bytes value to a real-world value: decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Decoded value (float): 99.99","title":"Response encoding/decoding"},{"location":"examples/spot_price_query_example/#full-example","text":"The full example is provided here for reference \"\"\"Text Query Example \"\"\" from telliot_core.api import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" )","title":"Full Example"},{"location":"examples/text_query_example/","text":"Text Query Example \u00b6 The following example demonstrates how to create a StringQuery request. Create a StringQuery and view the corresponding query descriptor:: \"\"\"Text Query Example \"\"\" from telliot_core.api import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"StringQuery\" , \"text\" : \"What is the meaning of life?\" } To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the StringQuery object: \"\"\"Text Query Example \"\"\" from telliot_core.api import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a22537472696e675175657279222c2274657874223a225768617420697320746865206d65616e696e67206f66206c6966653f227d tipQuery ID: 0xdd349fc565b13987a11bed4cc9e7382863491638769020afad1abe3840ec14b7 The StringQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit following the answer Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life use the encode and decode methods of the response ValueType . \"\"\"Text Query Example \"\"\" from telliot_core.api import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (str): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life submitValue (bytes): 0x000000000000000000000000000000000000000000000000000000000000003e506c6561736520726566657220746f3a2068747470733a2f2f656e2e77696b6970656469612e6f72672f77696b692f4d65616e696e675f6f665f6c6966650000 Decoded value (float): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life","title":"Text Query"},{"location":"examples/text_query_example/#text-query-example","text":"The following example demonstrates how to create a StringQuery request. Create a StringQuery and view the corresponding query descriptor:: \"\"\"Text Query Example \"\"\" from telliot_core.api import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"StringQuery\" , \"text\" : \"What is the meaning of life?\" } To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the StringQuery object: \"\"\"Text Query Example \"\"\" from telliot_core.api import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a22537472696e675175657279222c2274657874223a225768617420697320746865206d65616e696e67206f66206c6966653f227d tipQuery ID: 0xdd349fc565b13987a11bed4cc9e7382863491638769020afad1abe3840ec14b7 The StringQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit following the answer Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life use the encode and decode methods of the response ValueType . \"\"\"Text Query Example \"\"\" from telliot_core.api import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (str): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life submitValue (bytes): 0x000000000000000000000000000000000000000000000000000000000000003e506c6561736520726566657220746f3a2068747470733a2f2f656e2e77696b6970656469612e6f72672f77696b692f4d65616e696e675f6f665f6c6966650000 Decoded value (float): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life","title":"Text Query Example"}]}